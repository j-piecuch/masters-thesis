\documentclass[shortabstract, manyadvisors, english, mgr]{iithesis}
\usepackage[utf8]{inputenc}
\usepackage{amsthm, listings, epigraph, xcolor, graphicx, xurl}

\englishtitle{Implementation of the Terminal Subsystem \\ and Job Control \\
  in the Mimiker Operating System}
\polishtitle{Implementacja podsystemu terminali i kontroli zadań \\
  w systemie operacyjnym Mimiker}

\englishabstract{English Abstract}
\polishabstract{Polish Abstract}
\author{Jakub Piecuch}
\advisor{Krystian Bacławski \fmlinebreak Piotr Witkowski}

% \date{} % Data zlozenia pracy

\transcriptnum{281940}

\lstset{
  basicstyle=\ttfamily\small,
  numberstyle=\footnotesize,
  numbers=left,
  frame=single,
  extendedchars=true,
}

%%% Kolory do lstlistings
\definecolor{codegreen}{rgb}{0.1,0.35,0.2}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolor}{rgb}{0.9764705882352941,0.9607843137254902,0.8431372549019608}
\definecolor{stringcolor}{rgb}{0.4745098039215686,0.4549019607843137,0.054901960784313725}
\definecolor{commentcolor}{rgb}{0.6588235294117647,0.6,0.5176470588235295}
\definecolor{keywordcolor}{rgb}{0.61,0,0.02}

\lstdefinestyle{mylststyle}{
  backgroundcolor=\color{backcolor},
  commentstyle=\color{commentcolor},
  keywordstyle=\color{keywordcolor},%\color{codepurple},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{stringcolor},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=none,
  prebreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2
}
\lstset{style=mylststyle}

\begin{document}

\chapter{Introduction}

XXX nie jestem jeszcze pewien jak powinno wyglądać wprowadzenie. Zabiorę się za
nie jako ostatnie. To co jest teraz napisane prawdopodobnie wyrzucę, ale
zostawiam do wglądu.

POMYSŁ NA WPROWADZENIE:
\begin{itemize}
\item Przedstawienie kontroli zadań w powłoce (motywacja).
\item Jakie rzeczy są potrzebne żeby to wszystko działało? Sygnały, grupy
  procesów itp.
\item W Mimikerze to nie działało, a teraz działa, i o tym jest ta praca.
\end{itemize}

\section{What is a terminal?}

\subsection{Early-day terminals}

In the early days of computing, a computer had a single operator. Users would
submit their programs to the operator, usually on punched cards. When the user's
turn came, the operator would load the program into the machine, and collect the
output of the program in the form of punched cards. The whole process usually
took hours. If the program contained an error, the user would know about it no
sooner than when the operator loads it into the machine. Clearly, a more
interactive way of submitting programs for execution was needed.

Time-sharing systems were the solution to this problem. A time-sharing system
allows users to interact with the machine using a terminal. It gives the user an
illusion of exclusive posession of the machine's resources. In reality, the
operating system provides a fraction of the machine's computing resources to
each user. Multics\cite{multics} is an early example of a time-sharing operating
system.

In general, a terminal device is any device that allows its user to interact
with a computing system, such as a mainframe. It allows the user to input
commands, data, or even whole programs, and to examine the system's output.
A terminal could communicate with the system remotely, or be directly attached
to it.

In the beginning, terminals were electromechanical teletypewriters
(teletypes, or TTYs for short), initially used in telegraphy. A teletype
sends data typed on the keyboard to the computer, and prints the response.

In the 1970, video terminals came into widespread use. A video terminal displays
output on a screen instead of printing it. Most models provide a set of special
\textit{escape codes}: sequences of characters that, when sent to the terminal,
cause some action, e.g. clearing the screen. One of the most common features is
a cursor that can be controlled using escape codes. This made tasks such as
editing text much more enjoyable. The DEC VT100 series of video terminals was
extremely successful, and is the basis of a de facto standard for terminal
escape codes.

\subsection{Terminals in a modern context}

Nowadays, most people use their computer via a graphical user interface, or GUI.
There is no dedicated device that handles interaction between the system and the
user: input can be provided and output can be displayed by multiple devices. For
instance, user input can be provided by a combination of a keyboard and mouse,
and output can be displayed on a pair of monitors. Consequently, input and
output handling in GUI programs is considerably more complex compared to
programs written for character-based terminals. In addition, some people simply
prefer to use a text-based, non-graphical interface due to its efficiency. For
these reasons, it is useful to provide a means to run programs that use a
terminal-based interface. This is accomplished using a \textit{terminal
emulator}.

A terminal emulator is a GUI program that emulates a terminal device, usually
one that is compatible with the VT100 series of video terminals. The display of
the emulated terminal is presented in the emulator's GUI window. The emulator
translates the user's keystrokes into characters and feeds them as input to the
application running inside the emulator. Output from the application is
displayed in the GUI window in the same way it would be displayed on a real
video terminal's screen. \texttt{xterm} is an example of a terminal emulator.

Another area where terminal-based interfaces are still used is communication
over limited bandwidth connections, such as a Universal Asynchronous
Receiver/Transmitter (UART). Many development boards use a serial connection
as the primary way of communication with the user.

To summarize, even though 1970s-style video terminals are no longer used,
character-based computer interfaces that are compatible with those terminals
remain an important part, or even the basis of interaction between a user and a
computer system.

\section{Job Control}

The primary way of controlling a computer over a terminal connection is using a
\textit{shell}. A shell is a program that executes commands typed by the user.
The purpose of most commands is to run a specified program with a given set of
arguments. For example, the command \texttt{ls -l} instructs the shell to find a
program named \texttt{ls} and run it with a single argument \texttt{-l}.
The executed program will then run to completion. It may accept further input
from the user and write output. The shell waits for the program to finish, after
which it is ready to accept more commands from the user.

This example presented a very simple use case.
The user may want to execute \textit{jobs} that consist of a pipeline of
programs, with programs in the middle of the pipeline accepting input from the
previous one and feeding output to the next one. Such jobs may run for a long
time, so the user should be able to run any job in the background, without
making the shell wait for it to finish.

\textit{Job control} is a general feature of the system that allows the user to
control running jobs. A job may be suspended and resumed, terminated, a
background job may be brought into the foreground and vice versa. Job control
usually requires support from the operating system, and it's up to the shell to
group related programs into jobs.

\chapter{POSIX Terminals and Job Control}
% \section{What is POSIX?}
POSIX\cite{posix} is a set of standards specifying an operating system
interface. Its primary goal is to make it possible to write portable
applications that work across different operating systems, although the
application usually needs to be compiled for each operating system separately.

Among other things, it defines an Application Programming Interface (API) for
programs written in the C programming language that allows them to interact with
the system and use its services. Every POSIX-compliant operating system must
provide an implementation of this API.

The Mimiker operating system implements the POSIX API, but the implementation is
far from complete. This allows us to use existing programs using the POSIX API
like shells, command line utilities and text editors.

\section{POSIX Job Control}

\subsection{Jobs}
A job consists of one or more processes. The processes are usually connected in
a pipeline, with each one accepting input from the previous one in the chain,
and feeding output to the next one.

Jobs are a purely a shell concept: they are implemented entirely in the shell,
and the operating system has no knowledge of them. However, there is a close
correspondence between shell jobs and process groups, which are implemented by
the operating system. The shell puts jobs in their own process groups.
\subsection{Process groups}
Process groups are central to job control. They relate processes performing a
common task, such as a shell job. Process groups are identified by their
\textit{process group ID}, or \textit{PGID} for short.

Every process belongs to some process group. When a new process is created using
\texttt{fork()}\cite{fork}, it runs in the process group of its parent.

A process can change its own process group, or that of one of its children. This
is done using the \texttt{setpgid()}\cite{setpgid} function. It is used by the shell to set
the process group of all the processes in a job.

TODO orphaned process groups
\subsection{Sessions}
The concept of a session is fairly intuitive.
A new session starts when a user logs into the system. Initially, the user's
shell is the only process in the session. All jobs (and therefore process
groups) created by the shell belong to the same session. Every process group
must belong to exactly one session. Session are collections of process groups,
much in the same way as process groups are collections of processes.

Processes are not confined to their session: they can separate from it by
creating their own session using the \texttt{setsid()} function. It creates a
new session, initially containing just the calling process. All sessions are
created in this way. Creating a new session necessarily means also creating a
new process group: if it didn't, we could have two processes in the same process
group, but in different sessions.

The process that creates a new session is called the \textit{session leader}.
Usually, the session leader a is shell, or some other program ``in charge'' of
running and controlling all other programs in the session. It is supposed to
be the last process in its session to exit. If a session leader exits while its
session contains other processes, every process in the session will receive a
\texttt{SIGHUP} signal, whose default effect is to kill the receiving process.
Processes can ignore this signal, so it is possible for a session to outlive its
leader.

Some programs are supposed to run indefinitely and without user intervention.
A good example are \textit{daemons}: programs that run in the background, e.g.
providing services to other programs. A user may launch a daemon process from
the shell. If the shell process exits, the daemon should continue to run.
The daemon can become independent from the shell by creating its own session.
When the shell exits, the daemon will not be notified in any way.
Independence from the shell should not be confused with independence from the
\textit{user}: the user may open a shell in another session and send a signal to
the daemon process, e.g. \texttt{SIGKILL}.

\section{POSIX Terminals}
On the surface, a terminal device is no different than a standard characters
device: a process can open it using \texttt{open()} and then perform input and
output using \texttt{read()} and \texttt{write()} respectively.
The terminal interface specified by POSIX is much richer than that. Terminal
devices play a significant role in job control, and therefore are connected to
the concepts of process groups and sessions.

\subsection{Controlling terminals}
A terminal device may be the controlling terminal of a session. A session may
have at most one controlling terminal, and a terminal device may be the controlling
terminal of at most one session. A process can always access its controlling
terminal (if it has one) by opening the \texttt{/dev/tty} device file.

When a session is created, it has no controlling terminal. The session leader is
responsible for setting and changing the controlling terminal device, although
the way in which this is done is not specified in the standard.

When the leader of a session terminates, the controlling terminal (if any) is
dissociated from the session. Any processes left in the session may have their
access to the controlling terminal revoked. If a controlling terminal device
disappears from the system, the leader of the associated session is sent a
\texttt{SIGHUP} signal.

\subsection{Foreground process groups}
Access to the controlling terminal by processes can be controlled using
foreground and background process groups.

At any time, a process group can be designated as the foreground process group
of its session's controlling terminal. All other process groups in the session
are background process groups. The foreground process group of a terminal can be
set using the \texttt{tcsetpgrp()}\cite{tcsetpgrp} function. Any process can set the foreground
process group of its controlling terminal, although some restrictions apply to
processes from background process groups. A controlling terminal does not need
to have a foreground process group at all times.

Processes in the foreground process group are allowed to \texttt{read()} and
\texttt{write()} to their controlling terminal. When a process in a background
process group attempts to \texttt{read()} or \texttt{write()} to its controlling
terminal, every process in its process group is sent a \texttt{SIGTTIN} or
\texttt{SIGTTOU} signal respectively. The default effect of both signals is to
stop the target process. In the case of \texttt{write()}, the signal is sent
only if the \texttt{TOSTOP} terminal flag is set. If it is not set, background
processes can write to their controlling terminal without restrictions. The
exact semantics are a bit more nuanced, see \cite{terminal-access}.

When a shell is accepting input from the user, its process is necessarily in the
foreground process group. When the shell starts a job, the job is usually put in
the foreground, so that the user can interact with it. The shell waits for the
foreground job to complete, and then makes its own process group the foreground
process group, so that it can accept the next command.

The user may make the job run in the background by appending \texttt{\&} to the
command. In that case, the shell remains in the foreground process group and
does not wait for the job to complete. As explained earlier, a background job
will be stopped if it tries to accept input from the user.

A background job can be put in the foreground using the \texttt{fg} command. The
command simply sets the controlling terminal's foreground process group to the
process group of the target job, continues the target job if it was stopped, and
waits for the foreground job's termination.

\subsection{Terminal modes and flags}

Command line applications can be roughly divided into two groups, depending on
how they process user input:
\begin{itemize}
  \item{One line at a time (\textit{line-oriented});}
  \item{One character at a time (\textit{character-oriented}).}
\end{itemize}

A shell belongs to the first group. It accepts a whole command at a time. Most
notably, the user may edit the line before submitting it to the program by
pressing the return key (labelled ``enter'' on most keyboards).

A text editor belongs to the second group. Each key performs an action within
the editor, such as moving the cursor or inserting text at the position of the
cursor.

In serious applications, line-oriented input is usually accomplished using a
library such as GNU Readline \cite{readline}. However, POSIX mandates that basic
line-editing functionality is provided by the operating system itself.
Applications may choose whether they want to use this functionality by choosing
the \textit{terminal mode}.

Two terminal modes are distinguished: \textit{canonical} and
\textit{non-canonical} (often called \textit{raw}). Canonical mode provides
basic line editing:
\begin{itemize}
  \item{Characters typed by the user are ``echoed'' to the terminal;}
  \item{Characters may be erased from the line.}
\end{itemize}
It also causes certain actions to be taken in response to special
\textit{control characters} being received.

Character echoing allows the user to see the contents of the line they are
typing. This is necessary for the user to be able to spot mistakes in their
input. It is sometimes useful to turn off character echoing, e.g. when the user
is typing their password.

Characters can be erased from the line by sending certain control characters.
For instance, the \texttt{VERASE} character erases the character at the end of
the line, and the \texttt{VKILL} character causes the whole line to be erased.

Raw mode does not perform any processing on characters received from the device.
It is up to the application to perform tasks like echoing or erasing characters.
This is exactly what libraries such as GNU Readline do.

\subsubsection{The \texttt{termios} structure}

For each terminal device, all of its settings, including the terminal mode, are
stored in a \texttt{termios} structure associated with that terminal.
Application code may examine and modify the contents of this structure using the
\texttt{tcgetattr()}\cite{tcgetattr} and \texttt{tcsetattr()}\cite{tcsetattr} functions respectively.

The \texttt{termios} structure must contain the following fields:
\begin{itemize}
\item \texttt{c\_iflag}: contains bit fields that control basic
  terminal input handling. Some notable bit fields are:
  \begin{itemize}
  \item \texttt{ICRNL}: map the \textit{carriage return} (CR) character to the
    \textit{new line} (NL) character on input.
  \item \texttt{BRKINT}: send a \texttt{SIGINT} signal to the foreground process
    group upon detecting a break condition.
  \item \texttt{IGNBRK}: ignore hardware break conditions.
  \item \texttt{INPCK}: enable input parity checking.
  \item \texttt{IGNPAR}: ignore characters with parity errors.
  \end{itemize}
\item \texttt{c\_oflag}: contains bit fields that control terminal
  output processing. Some notable bit fields are:
  \begin{itemize}
  \item \texttt{OPOST}: enable output processing.
  \item \texttt{ONLCR}: map NL to CR-NL sequence on output.
  \item \texttt{OCRNL}: map CR to NL on output.
  \item \texttt{ONOCR}: do not output CR characters if the cursor is at column
    0.
  \end{itemize}
\item \texttt{c\_cflag}: contains bit fields that control terminal
  hardware parameters. Some notable bit fields are:
  \begin{itemize}
  \item \texttt{CREAD}: enable hardware receiver.
  \item \texttt{CSIZE}: number of bits transmitted or received per byte (from 5
    to 8).
  \end{itemize}
\item \texttt{c\_lflag}: contains bit fields that control various additional
  functions. Some notable bit fields are:
  \begin{itemize}
  \item \texttt{ECHO}: enable character echoing. This flag is cleared when the
    user is typing their password.

  \item \texttt{ICANON}: enable canonical mode.
  \item \texttt{ISIG}: send signals in response to certain control characters.
  \item \texttt{TOSTOP}: send \texttt{SIGTTOU} if a background process tries to
    write to the terminal.
  \end{itemize}
\item \texttt{c\_cc}: array defining control character codes. A control
  character can be disabled by setting its code to \texttt{\_POSIX\_VDISABLE}.
  Important control characters include:
  \begin{itemize}
  \item \texttt{VERASE}: erase the character at the end of the line.
  \item \texttt{VKILL}: erase the whole line.
  \item \texttt{VEOF}: marks end of user input.
  \item \texttt{VINTR}: if the \texttt{ISIG} flag is set, send \texttt{SIGINT}
    to the foreground process group.
  \item \texttt{VSUSP}: if the \texttt{ISIG} flag is set, send \texttt{SIGTSTP}
    (terminal stop signal) to the foreground process group.
  \end{itemize}
\end{itemize}
For the full specification of the \texttt{termios} structure, see
\cite{termios}.

\chapter{Implementation of POSIX Terminals and Job Control in the Mimiker
  Operating System}
\chaptermark{Implementation}
\section{Job Control}
\subsection{Jobs}
Jobs are purely a userspace concept, and are implemented by the shell. The
Mimiker operating system uses \texttt{ksh}, which is an existing implementation
of a POSIX compatible shell.
\subsection{Process groups}
A process group is represented in the kernel as a structure of type \texttt{pgrp\_t}.
\begin{lstlisting}[language=C,
caption={\texttt{include/sys/proc.h}: definition of \texttt{pgrp\_t}.}]
typedef struct pgrp {
  mtx_t pg_lock;
  TAILQ_ENTRY(pgrp) pg_hash;
  TAILQ_HEAD(, proc) pg_members;
  session_t *pg_session;
  int pg_jobc;
  pgid_t pg_id;
} pgrp_t;
\end{lstlisting}

The \texttt{pg\_lock} mutex synchronizes concurrent accesses to
\texttt{pg\_members}. \texttt{pg\_hash} is used to link the structure into the
global hash table mapping process group IDs to process group structures.
\texttt{pg\_members} is a list of processes belonging to this process group.
\texttt{pg\_session} points to the session that this process group belongs to.
\texttt{pg\_jobc} is a counter used to detect orphaned process groups.
\texttt{pg\_id} holds the process group ID.

\subsubsection{Orphaned process groups}

Let us say that a process \textit{qualifies its process group for job control}
when its parent process is in a different process group, but in the same
session. According to this notion, a process group is orphaned when it has no
processes that qualify it for job control.

The \texttt{pg\_jobc} field keeps track of the number of processes that qualify
the process group for job control. When it drops to 0, the process group becomes
orphaned, which results in \texttt{SIGHUP} and \texttt{SIGCONT} being sent to
every stopped process in the group.

The field's value requires adjustment whenever a process from the group or its
parent changes process groups. The \texttt{pgrp\_jobc\_enter()} and
\texttt{pgrp\_jobc\_leave()} functions perform the necessary adjustments when a
process enters or leaves a process group. When \texttt{pgrp\_jobc\_leave()}
notices a process group's \texttt{pg\_jobc} drop to 0, it orphans the process
group, sending the necessary signals.

\subsubsection{Process group lifecycle}

A new process group may be created only in \texttt{sys\_setpgid()}, which is the
kernel's implementation of the POSIX \texttt{setpgid()} function. Processes may
enter and leave the process group. When a process terminates and becomes a
zombie process, it remains on its process group's \texttt{pg\_members} list.
When a process is reaped, it is removed from the list.

Once the list is empty, the process group's lifetime ends. During deallocation,
a check is performed to see if the controlling terminal's foreground process
group is equal to the group being deallocated, in order to prevent a dangling
reference. If it is, the foreground process group is set to \texttt{NULL}.

TODO maybe some code walkthrough, e.g. \texttt{setpgid()}?

\subsection{Sessions}
\label{chapter:sessions}

The \texttt{session\_t} structure describes a session in the kernel.

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=C,
caption={\texttt{include/sys/proc.h}: definition of \texttt{session\_t}.}]
typedef struct session {
  TAILQ_ENTRY(session) s_hash;
  proc_t *s_leader;
  int s_count;
  sid_t s_sid;
  tty_t *s_tty;
} session_t;
\end{lstlisting}
\end{minipage}
The \texttt{s\_hash} field links the structure into the global hash table
mapping session IDs to session structures. \texttt{s\_leader} points to the
session leader if one exists. \texttt{s\_count} is the number of process groups
in the session. \texttt{s\_sid} holds the session ID. \texttt{s\_tty} points to
the session's controlling terminal, if any.

\section{Terminals}

The \texttt{tty\_t} structure encapsulates state associated with a single
terminal device.

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=c,
caption={\texttt{include/sys/tty.h}: definition of \texttt{tty\_t}.}]
typedef enum {
  TF_WAIT_OUT_LOWAT = 0x1,
  TF_WAIT_DRAIN_OUT = 0x2,
  TF_OUT_BUSY = 0x4,
} tty_flags_t;

typedef struct tty {
  mtx_t t_lock;
  tty_flags_t t_flags;
  ringbuf_t t_inq;
  condvar_t t_incv;
  ringbuf_t t_outq;
  condvar_t t_outcv;
  linebuf_t t_line;
  size_t t_column;
  size_t t_rocol, t_rocount;
  condvar_t t_serialize_cv;
  ttyops_t t_ops;
  struct termios t_termios;
  pgrp_t *t_pgrp;
  session_t *t_session;
  vnode_t *t_vnode;
  void *t_data;
} tty_t;
\end{lstlisting}
\end{minipage}
The \texttt{t\_lock} mutex synchronizes access to the structure.
\texttt{t\_flags} may contain the following flags:
\begin{itemize}
\item \texttt{TF\_WAIT\_OUT\_LOWAT}: a thread is waiting for space to become
  available in the output queue;
\item \texttt{TF\_WAIT\_DRAIN\_OUT}: a thread is waiting for the output queue to
  become empty;
\item \texttt{TF\_OUT\_BUSY}: a thread is currently writing to this terminal.
  This flag is used to serialize \texttt{write()} calls on a terminal device.
\end{itemize}

\texttt{t\_inq} is a ring buffer storing input coming from the terminal device.
\texttt{read()} calls on the terminal device file receive characters from this
buffer. \texttt{t\_incv} is a condition variable used to wait for input to
become available in \texttt{t\_inq}.

\texttt{t\_outq} is a ring buffer storing output from processes. The terminal
device driver reads characters from this buffer and takes care of transmitting
them. \textt{t\_outcv} is a condition variable used to wait for space to become
available in the output queue or for the queue to become empty.

\texttt{t\_line} stores the contents of the line the user is typing in canonical
mode. Its contents can be edited by the user. Once the user submits the line,
its contents are copied into \texttt{t\_inq}. The contents if \texttt{t\_inq}
cannot be changed. In raw mode, \texttt{t\_line} is not used.

\texttt{t\_column} keeps track of the position of the terminal cursor. It is
needed to support the \texttt{ONOCR} terminal flag, which forbids sending the
carriage return character when the cursor is at column 0.

The \texttt{t\_rocol} and \texttt{t\_rocount} fields are needed due to the fact
that the echoed line can be interleaved with output from processes, and we only
want to let the user erase the characters they typed, not ones output by
processes. The two fields keep track of the longest prefix of the line that is
not interrupted by output from processes.

The \texttt{t\_serialize\_cv} condition variable is used by processes calling
\texttt{write()} to wait for their turn to access the terminal.

\texttt{t\_ops} is a structure containing implementations of terminal device
driver operations. Currently, only one operation is provided by device drivers:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=c,
caption={\texttt{include/sys/tty.h}: definition of \texttt{ttyops\_t}.}]
typedef void (*t_notify_out_t)(struct tty *);

typedef struct {
  t_notify_out_t t_notify_out;
} ttyops_t;
\end{lstlisting}
\end{minipage}
The \texttt{t\_notify\_out} operation notifies the device driver that new data
has appeared in the terminal structure's output buffer. The driver should ensure
that data from the buffer is written out to the device as soon as possible.

\texttt{t\_termios} stores the terminal configuration described in the previous
chapter.

\texttt{t\_pgrp} points to the foreground process group, if any.

\texttt{t\_session} points to the session controlled by this terminal.

\texttt{t\_vnode} points to the filesystem node representing the terminal
device. It is used to implement the \texttt{/dev/tty} device file, which refers
different devices for processes in different sessions.

\texttt{t\_data} is an opaque pointer for the device driver to store its private
data.

\subsection{Creating a terminal device}

When a serial device driver attaches to a device, it is responsible for creating
its corresponding terminal device. This involves allocating a new \texttt{tty}
structure, setting device-specific fields in that structure (e.g.
\texttt{t\_ops}) and creating a terminal device node in the \texttt{/dev}
directory of the filesystem.

When creating the file, the driver supplies \texttt{tty\_fileops} as the
implementation of file operations. This way, \texttt{read()} and
\texttt{write()} (and other) calls on the file are directed to the TTY
subsystem, which may in turn call the serial device driver via \texttt{t\_ops}.

In the current implementation, which aims for simplicity, terminal devices live
forever. Once a terminal file is created, it never goes away.

\subsection{Terminal input}

Processes read data from a terminal by invoking \texttt{read()} on an open
terminal file descriptor. The terminal subsystem implements this operation in
the \texttt{tty\_read()} function.

As mandated by POSIX, the function first checks whether the calling process is
in the foreground process of its controlling terminal, if it has one. If it is,
the process may proceed. Otherwise, the process group of the calling process is
sent a \texttt{SIGTTIN} signal, which will stop the process until it is
resumed by a \texttt{SIGCONT} signal, most likely sent by the shell. The read
will then be attempted again.

After passing the check, the process checks whether there are characters
available in the terminal's input buffer. If it is empty, the process goes to
sleep on the \texttt{t\_incv} condition variable. The process will be woken up
once there is data in the buffer.

If the input buffer contains characters, the process copies them into the
userspace buffer supplied as an argument to \texttt{read()}. In canonical mode,
care must be taken not to read more than a single line. If a line-terminating
character is read from the buffer, no further characters are copied, but the
line-terminating character is (with the exception of the special character
\texttt{VEOF}).

We have covered how characters find their way from the terminal input buffer to
the buffer supplied by the reading user process. The question that remains is:
How are characters written into the input buffer?

A character's journey through the kernel begins with its reception by the
serial device. An interrupt-driven device (e.g. a UART) signals the reception of
a character by asserting its interrupt line, which will eventually lead to
interrupting the CPU. The CPU will then jump to an \textit{interrupt service
  routine}, or ISR.

The ISR will execute the serial device driver's code that extracts the character
from the device registers and inserts it into the serial device's
\textit{receive buffer}. This buffer is different from the associated terminal's
input buffer. The driver will then wake up a worker thread that copies
characters from the receive buffer into the terminal's input buffer.

Characters being copied from the receive buffer must be processed in order to
take appropriate actions in response to certain control characters being
received. The degree of processing depends on the state of flags in the
\texttt{termios} structure. For instance, if the \texttt{ISIG} flag is set, the
characters \texttt{VINTR}, \texttt{VSUSP} and \texttt{VQUIT} respectively cause
a \texttt{SIGINT}, \texttt{SIGTSTP} or \texttt{SIGQUIT} signal to be sent to the
foreground process group of the receiving terminal.

The terminal subsystem provides the \texttt{tty\_input()} function for inserting
characters into the terminal input buffer. The function accepts a character and
performs processing on it before appending it to the line buffer or the input
buffer. Its control flow can be summarized by the following pseudocode:

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=c,
caption={\texttt{kern/tty.c}: simplified control flow of \texttt{tty\_input()}.}]
void tty_input(tty_t *tty, uint8_t c) {
  if (ISIG flag is set) {
    /* Signal processing */
    if (c is VINTR or VSUSP or VQUIT) {
      send the appropriate signal to the foreground process group;
      return;
    }
  }

  if (ICANON flag is set) {
    /* Line editing */
    if (c is VERASE or VKILL) {
      erase the approriate characters from the line;
      return;
    }

    insert c into the line buffer;
    
    if (c is a line terminator) {
      copy the line buffer to the input buffer; 
    }
  } else {
    insert c into the input buffer;
  }

  if (ECHO flag is set) {
    echo c;
  }
}
\end{lstlisting}
\end{minipage}

The \texttt{tty\_input()} function cannot be called from an ISR, as the function
uses blocking synchronization primitives, such as mutexes. This is why a worker
thread is used instead of calling \texttt{tty\_input()} directly from an ISR.

\subsection{Terminal output}

Processes write data to a terminal by invoking \texttt{write()} on an open
terminal file descriptor. The kernel in turn calls \texttt{tty\_write()} to
carry out the operation.

If the \texttt{TOSTOP} terminal flag is set, a background check similar to the
one in \texttt{tty\_read()} is performed, with the difference that the signal
sent to the offending process group is \texttt{SIGTTOU} instead of
\texttt{SIGTTIN}.

After passing the check, the calling process writes the data into the terminal's
output buffer. If at any point the buffer becomes full, the process goes to
sleep on the \texttt{t\_outcv} condition variable, waiting for the serial device
driver to make space in the buffer.

After writing data to the output buffer or before going to sleep on
\texttt{t\_outcv}, the serial device driver is notified of new data. The
\texttt{tty\_notify\_out()} function calls the \texttt{t\_notify\_out} function
supplied by the driver. After that point, it is the responsibility of the driver
to write the characters in \texttt{t\_outq} to the serial device.

Unlike in the case of terminal input, the driver does not need to use an
intermediate buffer between the terminal's output buffer and the hardware. It
may simply write all data from the buffer in a single invocation of
\texttt{t\_notify\_out}. In other words, the driver may output the characters
\textit{synchronously}. However, that would most likely require busy-waiting for
the hardware to become ready to accept data, unnecessarily consuming CPU time.
For this reason, an \textit{asynchronous} approach is taken in the UART driver
found in the Mimiker kernel.

The driver's implementation of \texttt{t\_notify\_out} copies characters from
the terminal's output buffer to the \textit{transmit buffer} associated with the
device. Actual output is performed in the driver's ISR: the hardware signals
that is ready to accept a character via an interrupt. The ISR then takes one
character from the transmit buffer and writes it to a hardware register. When
the transmit buffer runs out of characters, the ISR wakes up a worker thread
that copies characters from the terminal's output buffer into the transmit
buffer. The actual implementation doesn't perform output exclusively from the
ISR, but that is just an optimization.

In the case of asynchronous drivers, the driver is also responsible for waking
up writers waiting for space in the terminal's output buffer. This is done by
calling the \texttt{tty\_getc\_done()} function after copying characters from
the output queue. This function simply checks whether the number of characters
in the output buffer has fallen below some threshold. If it has, it wakes up all
waiters waiting on \texttt{t\_outcv}. Similarly to \texttt{tty\_input()}, this
function cannot be called from an ISR, as it uses blocking synchronization
primitives.

\subsection{Controlling terminals}

As seen in section \ref{chapter:sessions}, the controlling terminal for a
session is stored in the \texttt{s\_tty} field of \texttt{session\_t}. When a
new session is created, its \texttt{s\_tty} field is set to \texttt{NULL}.

A terminal becomes associated with a session automatically when a session leader
opens a terminal device file. The association happens only when the session
doesn't already have a controlling terminal, and the terminal being opened isn't
associated with any session.

When the session leader process exits, the session loses its controlling
terminal. This is the only way a terminal may become dissociated from its
session.

\subsection{Foreground process groups}
\chapter{Implementation Challenges}
\section{Process control}
\subsection{Stopping and resuming processes with signals}
\subsection{Interruptible sleep and stop signals}
\section{Locking}
\chapter{Conclusion}

\bibliography{bibliography}
\bibliographystyle{plain}
\end{document}
